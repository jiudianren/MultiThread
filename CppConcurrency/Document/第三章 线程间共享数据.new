### 3.2.4 死锁：问题描述及解决方案

但线程有对锁的竞争：
一对线程需要对他们所有的互斥量做一些操作，其中每个线程都有一个互斥量，且等待另一个解锁。

这样没有线程能工作，因为他们都在等待对方释放互斥量。这种情况就是`死锁`，

它的最大问题就是由两个或两个以上的互斥量来锁定一个操作。

避免死锁的一般建议，就是`让两个互斥量总以相同的顺序上锁`。


某些情况下是可以这样用，因为不同的互斥量用于不同的地方。不过，
事情没那么简单，比如：当有多个互斥量保护同一个类的独立实例时，一个操作对同一个类
的两个不同实例进行数据的交换操作，为了保证数据交换操作的正确性，就要避免数据被并
发修改，并确保每个实例上的互斥量都能锁住自己要保护的区域。不过，选择一个固定的顺
序(例如，实例提供的第一互斥量作为第一个参数，提供的第二个互斥量为第二个参数)，可能
会适得其反：在参数交换了之后，两个线程试图在相同的两个实例间进行数据交换时，程序
又死锁了！



std::lock()
std::lock_guard()

	
	class some_big_object;
	void swap(some_big_object& lhs,some_big_object& rhs);
	class X
	{ p
	rivate:
	some_big_object some_detail;
	std::mutex m;
	public:
	X(some_big_object const& sd):some_detail(sd){}
	
	friend void swap(X& lhs, X& rhs)
	{
		if(&lhs==&rhs)
		return;
		
		std::lock(lhs.m,rhs.m); // 1
		std::lock_guard<std::mutex> lock_a(lhs.m,std::adopt_lock);
		// 2
		std::lock_guard<std::mutex> lock_b(rhs.m,std::adopt_lock);
		// 3
		swap(lhs.some_detail,rhs.some_detail);
	}
	};
	
	

当 std::lock 成功的获取一个互斥量上的锁，并且当其尝试从另一个互斥量上再获取锁时，就会有异常抛出，第一个锁也会随着异常的产生而自动释放，所
以 std::lock 要么将两个锁都锁住，要不一个都不锁。



无锁的情况下，仅需要每个 std::thread 对象调用join()，两个线程就能产生死锁。
	
	这种情况下，没有线程可以继续运行，因为他们正在互相等待。

这种情况很常见，一个线程会等待另一个线程，其他线程同时也会等待第一个线程结束，所以三个或更多线程的互相等待也会发生死锁。
为了避免死锁，这里的指导意见为：
	
	当机会来临时，不要拱手让人
	
以下提供一些个人的指导建议，如何识别死锁，并消除其他线程的等待。
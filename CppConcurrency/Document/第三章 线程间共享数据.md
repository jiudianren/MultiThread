
#本章主要内容

	共享数据带来的问题
	使用互斥量保护数据
	数据保护的替代方案

##3.1 共享数据带来的问题

但是，当一个或多个线程要修改共享数据时，就会产生很多麻烦。这种情况下，就必须
小心谨慎，才能确保一切所有线程都工作正常


不变量(invariants)的概念对程序员们编写的程序会有一定的帮助――对于特殊结构体的描
述；比如，“变量包含列表中的项数”。不变量通常会在一次更新中被破坏，特别是比较复杂的
数据结构，或者一次更新就要改动很大的数据结构.


双向链表中删除其中一个节点的线程安全的操作：


从一个列表中删除一个节点的步骤如下(如图3.1)
1. 找到要删除的节点N
2. 更新前一个节点指向N的指针，让这个指针指向N的下一个节点
3. 更新后一个节点指向N的指针，让这个指正指向N的前一个节点
4. 删除节点N




### 3.1.1  条件竞争

C++ 标准中也定义了数据竞争这个术语，一种特殊的条件竞争：

	并发的去修改一个独立对象(参见5.1.2节)，数据竞争是(可怕的)未定义行为的起因



当系统负载增加时，随着执行数量的增加，执
行序列的问题复现的概率也在增加，这样的问题只可能会出现在负载比较大的情况下。条件
竞争通常是时间敏感的，所以程序以调试模式运行时，它们常会完全消失，因为调试模式会
影响程序的执行时间(即使影响不多)


### 3.1.2 避免恶性竞争

这里提供一些方法来解决恶性条件竞争，最简单的办法就是对数据结构采用某种保护机制，

	确保只有进行修改的线程才能看到不变量被破坏时的中间状态。从其他访问线程的角度来看，修改不是已经完成了，就是还没开始。

 C++ 标准库提供很多类似的机制，下面会逐一介绍。
 
	另一个选择是对数据结构和不变量的设计进行修改，修改完的结构必须能完成一系列不可分
	割的变化，也就是保证每个不变量保持稳定的状态，这就是所谓的无锁编程。

不过，这种方式很难得到正确的结果。如果到这个级别，无论是内存模型上的细微差异，还是线程访问数
据的能力，都会让工作变的复杂。


	另一种处理条件竞争的方式是，使用事务的方式去处理数据结构的更新(这里的"处理"就如同对数据库进行更新一样)。
	所需的一些数据和读取都存储在事务日志中，然后将之前的操作合为一步，再进行提交。
当数据结构被另一个线程修改后，或处理已经重启的情况下，提交就
会无法进行，这称作为“软件事务内存”。


	保护共享数据结构的最基本的方式，是使用C++标准库提供的互斥量
	


## 3.2 使用互斥量保护数据


互斥量是 C++ 中一种最通用的数据保护机制，但它不是“银弹”；精心组织代码来保护正确的数
据(见3.2.2节)，并在接口内部避免竞争条件(见3.2.3节)是非常重要的。

但互斥量自身也有问题，也会造成死锁(见3.2.4节)，或是对数据保护的太多(或太少)(见3.2.8节)。



### 3.2.1 c++中使用的互斥量 


C++中通过实例化 `std::mutex` 创建互斥量，

	通过调用成员函数lock()进行上锁，unlock()进行解锁。
不过，不推荐实践中直接去调用成员函数，因为调用成员函数就意味着，必须记住在
每个函数出口都要去调用unlock()，也包括异常的情况。

C++标准库为互斥量提供了一个RAII语法的模板类
` std::lock_guard` ，其会在构造的时候提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁的互斥量总是会被正确的解锁


虽然某些情况下，使用全局变量没问题，但在大多数情况下，

	互斥量通常会与保护的数据放在同一个类中，而不是定义成全局变量。

当然，也不是总是那么理想，聪明的你一定注意到了：

	当其中一个成员函数返回的是保护数据的指针或引用时，会破坏对数据的保护。


### 3.2.2 精心组织 代码保护共享数据


不过，检查迷失指针或引用是很容易的，

	只要没有成员函数通过返回值或者输出参数的形式向其调用者返回指向受保护数据的指针或引用，数据就是安全的。

如果你还想往祖坟上刨，就没这么简单了。在确保成员
函数不会传出指针或引用的同时，

	检查成员函数是否通过指针或引用的方式来调用也是很重要的(尤其是这个操作不在你的控制下时)。
	
从乐观的角度上看，还是有方法可循的：

	切勿将受保护数据的指针或引用传递到互斥锁作用域之外，无论是函数返回值，还是存储在外部可见内存，亦或是以参数的形式传递到用户提供的函数中去。


### 3.2.3 发现接口内在的条件竞争



### 3.2.4 死锁：问题描述及解决方案

但线程有对锁的竞争：
一对线程需要对他们所有的互斥量做一些操作，其中每个线程都有一个互斥量，且等待另一个解锁。

这样没有线程能工作，因为他们都在等待对方释放互斥量。这种情况就是`死锁`，

它的最大问题就是由两个或两个以上的互斥量来锁定一个操作。

避免死锁的一般建议，就是`让两个互斥量总以相同的顺序上锁`。


某些情况下是可以这样用，因为不同的互斥量用于不同的地方。
不过，事情没那么简单，比如：当有多个互斥量保护同一个类的独立实例时，一个操作对同一个类
的两个不同实例进行数据的交换操作，为了保证数据交换操作的正确性，就要避免数据被并
发修改，并确保每个实例上的互斥量都能锁住自己要保护的区域。不过，选择一个固定的顺
序(例如，实例提供的第一互斥量作为第一个参数，提供的第二个互斥量为第二个参数)，可能
会适得其反：在参数交换了之后，两个线程试图在相同的两个实例间进行数据交换时，程序
又死锁了！



std::lock()
std::lock_guard()

	
	class some_big_object;
	void swap(some_big_object& lhs,some_big_object& rhs);
	class X
	{ p
	rivate:
	some_big_object some_detail;
	std::mutex m;
	public:
	X(some_big_object const& sd):some_detail(sd){}
	
	friend void swap(X& lhs, X& rhs)
	{
		if(&lhs==&rhs)
		return;
		
		std::lock(lhs.m,rhs.m); // 1
		std::lock_guard<std::mutex> lock_a(lhs.m,std::adopt_lock);
		// 2
		std::lock_guard<std::mutex> lock_b(rhs.m,std::adopt_lock);
		// 3
		swap(lhs.some_detail,rhs.some_detail);
	}
	};
	
	

当 std::lock 成功的获取一个互斥量上的锁，并且当其尝试从另一个互斥量上再获取锁时，就会有异常抛出，第一个锁也会随着异常的产生而自动释放，所
以 std::lock 要么将两个锁都锁住，要不一个都不锁。



无锁的情况下，仅需要每个 std::thread 对象调用join()，两个线程就能产生死锁。
	
	这种情况下，没有线程可以继续运行，因为他们正在互相等待。

这种情况很常见，一个线程会等待另一个线程，其他线程同时也会等待第一个线程结束，所以三个或更多线程的互相等待也会发生死锁。
为了避免死锁，这里的指导意见为：
	
	当机会来临时，不要拱手让人
	
以下提供一些个人的指导建议，如何识别死锁，并消除其他线程的等待。


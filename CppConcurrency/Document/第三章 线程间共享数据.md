
本章主要内容
共享数据带来的问题
使用互斥量保护数据
数据保护的替代方案

##3.1 共享数据带来的问题

但是，当一个或多个线程要修改共享数据时，就会产生很多麻烦。这种情况下，就必须
小心谨慎，才能确保一切所有线程都工作正常


不变量(invariants)的概念对程序员们编写的程序会有一定的帮助――对于特殊结构体的描
述；比如，“变量包含列表中的项数”。不变量通常会在一次更新中被破坏，特别是比较复杂的
数据结构，或者一次更新就要改动很大的数据结构

### 3.1.1  条件竞争

C++ 标准中也定义了数据竞争这个术语，一种特殊的条件竞争：

	并发的去修改一个独立对象(参见5.1.2节)，数据竞争是(可怕的)未定义行为的起因

### 3.1.2 避免恶性竞争

这里提供一些方法来解决恶性条件竞争，最简单的办法就是对数据结构采用某种保护机制，
确保只有进行修改的线程才能看到不变量被破坏时的中间状态。从其他访问线程的角度来
看，修改不是已经完成了，就是还没开始。 C++ 标准库提供很多类似的机制，下面会逐一介
绍。
另一个选择是对数据结构和不变量的设计进行修改，修改完的结构必须能完成一系列不可分
割的变化，也就是保证每个不变量保持稳定的状态，这就是所谓的无锁编程。不过，这种方
式很难得到正确的结果。如果到这个级别，无论是内存模型上的细微差异，还是线程访问数
据的能力，都会让工作变的复杂。


另一种处理条件竞争的方式是，使用事务的方式去处理数据结构的更新(这里的"处理"就如同
对数据库进行更新一样)。所需的一些数据和读取都存储在事务日志中，然后将之前的操作合
为一步，再进行提交。当数据结构被另一个线程修改后，或处理已经重启的情况下，提交就
会无法进行，这称作为“软件事务内存”。


	保护共享数据结构的最基本的方式，是使用C++标准库提供的互斥量
	


## 3.2 使用互斥量保护数据
### 3.2.1 c++中使用的互斥量 


C++中通过实例化 `std::mutex` 创建互斥量，

	通过调用成员函数lock()进行上锁，unlock()进行解锁。
不过，不推荐实践中直接去调用成员函数，因为调用成员函数就意味着，必须记住在
每个函数出口都要去调用unlock()，也包括异常的情况。

C++标准库为互斥量提供了一个RAII语法的模板类
` std::lock_guard` ，其会在构造的时候提供已锁的互斥量，并在析构的时候进行解锁，从而保证了一个已锁的互斥量总是会被正确的解锁


虽然某些情况下，使用全局变量没问题，但在大多数情况下，

	互斥量通常会与保护的数据放在同一个类中，而不是定义成全局变量。

当然，也不是总是那么理想，聪明的你一定注意到了：当其中一个成员函数返回的是保护数
据的指针或引用时，会破坏对数据的保护。


### 3.2.2 精心组织 代码保护共享数据


不过，检查迷失指针或引用是很容易的，

	只要没有成员函数通过返回值或者输出参数的形式向其调用者返回指向受保护数据的指针或引用，数据就是安全的。

如果你还想往祖坟上刨，就没这么简单了。在确保成员
函数不会传出指针或引用的同时，

	检查成员函数是否通过指针或引用的方式来调用也是很重要的(尤其是这个操作不在你的控制下时)。
	
从乐观的角度上看，还是有方法可循的：

	切勿将受保护数据的指针或引用传递到互斥锁作用域之外，无论是函数返回值，还是存储在外部可见内存，亦或是以参数的形式传递到用户提供的函数中去。


### 3.2.3 发现接口内在的条件竞争







本章将从基本开始：启动一个线程，等待这个线程结束，或放在后台运行。再看看怎么给已
经启动的线程函数传递参数，以及怎么将一个线程的所有权从当前 std::thread 对象移交给另
一个。最后，再来确定线程数，以及识别特殊线程


##2.1.1

	
	有件事需要注意，当把函数对象传入到线程构造函数中时，需要避免“最令人头痛的语法解
	析”(C++’s most vexing parse, 中文简介)。如果你传递了一个临时变量，而不是一个命名的变
	量；C++编译器会将其解析为函数声明，而不是类型对象的定义


	启动了线程，你需要明确是要等待线程结束(加入式――参见2.1.2节)，还是让其自主运行(分离式――参见2.1.3节)。

如果 std::thread 对象销毁之前还没有做出决定，程序就会终止
( std::thread 的析构函数会调用 std::terminate() )。因此，即便是有异常存在，也需要确保
线程能够正确的加入(joined)或分离(detached)。2.1.3节中，会介绍对应的方法来处理这两种
情况。需要注意的是，必须在 std::thread 对象销毁之前做出决定，否则你的程序将会终止
(std::thread的析构函数会调用std::terminate()，这时再去决定会触发相应异常)。



处理这种情况的常规方法：使线程函数的功能齐全，将数据复制到线程中，而非复制到共享
数据中。如果使用一个可调用的对象作为线程函数，这个对象就会复制到线程中，而后原始
对象就会立即销毁。但对于对象中包含的指针和引用还需谨慎

##2.1.3

##2.1.4

通常称分离线程为守护线程(daemon threads),UNIX中守护线程是指，没有任何显式的用户接
口，并在后台运行的线程。这种线程的特点就是长时间运行；线程的生命周期可能会从某一
个应用起始到结束，可能会在后台监视文件系统，还有可能对缓存进行清理，亦或对数据结
构进行优化。另一方面，分离线程的另一方面只能确定线程什么时候结束，发后即忘(fire and
forget)的任务就使用到线程的这种方式


这个例子也展示了传参启动线程的方法：不仅可以向 std::thread 构造函数①传递函数名，还
可以传递函数所需的参数(实参)。C++线程库的方式也不是很复杂。当然，也有其他方法完成
这项功能，比如:使用一个带有数据成员的成员函数，代替一个需要传参的普通函数。

##2.2 线程传参


期望传递一个引用，但整个对象被复制了

标准线程库中和 std::unique_ptr 在所属权上有相似语义类型的类有好几种， std::thread 为
其中之一。虽然， std::thread 实例不像 std::unique_ptr 那样能占有一个动态对象的所有
权，但是它能占有其他资源：每个实例都负责管理一个执行线程。执行线程的所有权可以在
多个 std::thread 实例中互相转移，这是依赖于 std::thread 实例的可移动且不可复制性。不
可复制保性证了在同一时间点，一个 std::thread 实例只能关联一个执行线程；可移动性使得
程序员可以自己决定，哪个实例拥有实际执行线程的所有权。

##2.3 转移线程所有权



# 同步并发操作
C++ 标准库提供了一些工具可用于同步操作，
形式上表现为`条件变量(condition variables)和期望(futures)`。



##4.1 等待一个事件或其他条件

而且正在一辆在夜间运行的火车上。在夜间，如何在正确的站点下车呢？

	第一：
	 一种方法是整晚都要醒着，然后注意到了哪一站。这样，你就不会错过你要到达的站点，但是
	这样会让你感到很疲倦。
	
	第二：
	另外，你可以看一下时间表，估计一下火车到达目的地的时间，然
	后在一个稍早的时间点上设置闹铃，然后你就可以安心的睡会了。这个方法听起来也很不
	错，也没有错过你要下车的站点，但是当火车晚点的时候，你就要被过早的叫醒了。当然，
	闹钟的电池也可能会没电了，并导致你睡过站。
	
	第三： 
	理想的方式是，无论是早或晚，只要当火车到站的时候，有人或其他东西能把你唤醒，就好了。

对应线程同步三种方式。


	bool flag;
	std::mutex m;
	void wait_for_flag()
	{
		std::unique_lock<std::mutex> lk(m);
		while(!flag)
		{
			lk.unlock(); // 1 解锁互斥量
			std::this_thread::sleep_for(std::chrono::milliseconds(100));
			// 2 休眠100ms
			lk.lock(); // 3 再锁互斥量
		}
	}
	

### 4.1.1 等待条件达成

C++标准库对条件变量有两套实现：` std::condition_variable 和 std::condition_variable_any `。
这两个实现都包含在 <condition_variable> 头文件的声明中。
两者都需要与一个互斥量一起才能工作(互斥量是为了同步)；

前者仅限于与 std::mutex 一起工作，而后者可以和任何满足最低标准的互斥量一起工作，从而加上了_any的后缀。
因为 std::condition_variable_any 更加通用，这就可能从体积、性能，以及系统资源的使用方面产生额外的开销，
所以 std::condition_variable 一般作为首选的类型，当对灵活性有硬性要求时，我们才会去考虑 std::condition_variable_any



	std::mutex mut;
	std::queue<data_chunk> data_queue; // 1
	std::condition_variable data_cond;
	
	void data_preparation_thread()
	{
		while(more_data_to_prepare())
		{
			data_chunk const data= prepare_data();
			std::lock_guard<std::mutex> lk(mut);
			data_queue.push(data); // 2
			data_cond.notify_one(); // 3
		}
	} 
	
	void data_processing_thread()
	{
		while(true)
		{
			std::unique_lock<std::mutex> lk(mut); // 4
			data_cond.wait(lk,[]{return !data_queue.empty();}); // 5
			
			data_chunk data=data_queue.front();
			data_queue.pop();
			lk.unlock(); // 6
			process(data);
			
			if(is_last_chunk(data))
			break;
		}
	}




wait()会去检查这些条件(通过调用所提供的lambda函数):
	
	当条件满足(lambda函数返回true)时返回。
	
	如果条件不满足(lambda函数返回false)，wait()函数将解锁互斥量，并且将这个线程(上段提到的处理数据的线程)置于阻塞或等待状态。
	当准备数据的线程调用notify_one()通知条件变量时，
	处理数据的线程从睡眠状态中苏醒，重新获取互斥锁，并且对条件再次检查，
	(重新获取互斥锁，并且对条件再次检查，这个动作是wait，自身完成的)
	在条件满足的情况下，从wait()返回并继续持有锁。
	
	
在调用wait()的过程中，一个条件变量可能会去检查给定条件若干次；然
而，它总是在互斥量被锁定时这样做，当且仅当提供测试条件的函数返回true时，它就会立即
返回。
因为任何伪唤醒的数量和频率都是不确定的，这里
不建议使用一个有副作用的函数做条件检查。当你这样做了，就必须做好多次产生副作用的
心理准备。



###4.1.2 使用条件变量构建线程安全队列 （后续补充）



## 4.2 使用期望等待一次性事件




C++ 标准库模型将这种一次性事件称为期望(future)。
当一个线程需要等待一个特定的一次性事件时，在某种程度上来说它就需要知道这个事件在未来的表现形式。
之后，这个线程会周期性(较短的周期)的等待或检查，事件是否触发(检查信息板)；在检查期间也会执行其他任务
(品尝昂贵的咖啡)。另外，在等待任务期间它可以先执行另外一些任务，直到对应的任务触发，而后等待期望的状态会变为就绪(ready)。
一个“期望”可能是数据相关的(比如，你的登机口编号)，也可能不是。当事件发生时(并且期望状态为就绪)，这个“期望”就不能被重置。



在C++标准库中，有两种“期望”，使用两种类型模板实现，声明在头文件中: `唯一期望(unique futures)( std::future<> )和共享期望(shared futures)( std::shared_future<> )`。

std::future 的实例只能与一个指定事件相关联，而 std::shared_future 的实例就能关联多个事件

虽然，我希望用于线程间的通讯，但是“期望”对象本身并不提供同步访问。
当多个线程需要访问一个独立“期望”对象时，他们必须使用互斥量或类似同步机制对访问进行保护，如在第3章提到的那
样。
不过，在你将要阅读到的4.2.5节中，多个线程会对一个 std::shared_future<> 实例的副本进行访问，而不需要期望同步，即使他们是同一个异步结果


在第2章中，你已经了解
了 std::thread 执行的任务不能有返回值，并且我能保证，这个问题将在使用“期望”后解决
――现在就来看看是怎么解决的


### 4.2.1 带返回值的后台任务

	
	#include <future>
	#include <iostream>
	int find_the_answer_to_ltuae();
	void do_other_stuff();
	int main()
	{
		std::future<int>
		the_answer=std::async(find_the_answer_to_ltuae);
		do_other_stuff();
		std::cout<<"The answer is "<<the_answer.get()<<std::endl;
	}
	
	

这个参数的类型是 std::launch ，还可以是 
 std::launch::defered ，用来表明函数调用被延迟到wait()或get()函数调用时才执行，
 std::launch::async 表明函数必须在其所在的独立线程上执行，
 std::launch::deferred| std::launch::async 表明实现可以选择这两种方式的一种。
  最后一个选项是默认的。当函数调用被延迟，它可能不会在运行了	
  
  
  
  不过，这不是让一个 std::future 与一个任务实例相关联的唯一方式；
  你也可以将任务包装入一个 std::packaged_task<> 实例中，
  或通过编写代码的方式，使用 std::promise<> 类型模板显示设置值。

### 4.2.2 任务与期望



std::packaged_task<> 对一个函数或可调用对象，绑定一个期望。
当 std::packaged_task<>对象被调用，它就会调用相关函数或可调用对象，将期望状态置为就绪，返回值也会被存储为相关数据。



当一个粒度较
大的操作可以被分解为独立的子任务时，其中每个子任务就可以包含在一
个 std::packaged_task<> 实例中，之后这个实例将传递到任务调度器或线程池中。对任务的细
节进行抽象，调度器仅处理 std::packaged_task<> 实例，而非处理单独的函数。


当你需要异步任务的返回值时，你可以等待期望的状态变为“就绪”。

这些任务能作为一个简单的函数调用来表达吗？还有，这些任务的结果能从很多地方得到吗？
这些情况可以使用第三种方法创建“期望”来解决：使用 std::promise 对值进行显示设置。

### 4.2.3 使用std::promises






